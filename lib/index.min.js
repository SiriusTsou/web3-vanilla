!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@0x/subproviders"),require("ethers"));else if("function"==typeof define&&define.amd)define(["@0x/subproviders","ethers"],t);else{var r="object"==typeof exports?t(require("@0x/subproviders"),require("ethers")):t(e["@0x/subproviders"],e.ethers);for(var n in r)("object"==typeof exports?exports:e)[n]=r[n]}}(global,function(e,t){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=3)}([function(t,r){t.exports=e},function(e,r){e.exports=t},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";r.r(t);var n={};r.r(n),r.d(n,"Connector",function(){return d}),r.d(n,"InjectedConnector",function(){return h}),r.d(n,"NetworkOnlyConnector",function(){return p}),r.d(n,"PrivateKeyConnector",function(){return l}),r.d(n,"ErrorCodeMixin",function(){return a});var o=r(1),i=r(2),s=r.n(i);function a(e,t){return class extends e{constructor(e={}){super(e)}static get errorCodes(){return t.reduce((e,t)=>(e[t]=t,e),{})}}}const c=["UNSUPPORTED_NETWORK"];class d extends(a(s.a,c)){constructor(e={}){super();const{supportedNetworks:t}=e;this.supportedNetworks=t}async onActivation(){}onDeactivation(e){}async getProvider(e){}async getNetworkId(e){const t=new o.ethers.providers.Web3Provider(e),r=await t.getNetwork().then(e=>e.chainId);return this._validateNetworkId(r)}async getAccount(e){const t=new o.ethers.providers.Web3Provider(e);return await t.listAccounts().then(e=>e[0]||null)}_validateNetworkId(e){if(this.supportedNetworks&&!this.supportedNetworks.includes(e)){const t=Error(`Unsupported Network: ${e}.`);throw t.code=d.errorCodes.UNSUPPORTED_NETWORK,t}return e}_web3UpdateHandler(e){this.emit("_web3Update",e)}_web3ErrorHandler(e,t=!0){this.emit("_web3Error",e,t)}_web3ResetHandler(){this.emit("_web3Reset")}}const u=["ETHEREUM_ACCESS_DENIED","LEGACY_PROVIDER","NO_WEB3","UNLOCK_REQUIRED"];class h extends(a(d,u)){constructor(e={}){super(e),this.runOnDeactivation=[],this.networkChangedHandler=this.networkChangedHandler.bind(this),this.accountsChangedHandler=this.accountsChangedHandler.bind(this)}async onActivation(){const{ethereum:e,web3:t}=window;if(!e){if(t){const e=Error("Your web3 provider is outdated, please upgrade to a modern provider.");throw e.code=h.errorCodes.LEGACY_PROVIDER,e}{const e=Error("Your browser is not equipped with web3 capabilities.");throw e.code=h.errorCodes.NO_WEB3,e}}await e.enable().catch(e=>{const t=Error(e);throw t.code=h.errorCodes.ETHEREUM_ACCESS_DENIED,t}),e.on&&(e.on("networkChanged",this.networkChangedHandler),e.on("accountsChanged",this.accountsChangedHandler),this.runOnDeactivation.push(()=>{e.removeListener&&(e.removeListener("networkChanged",this.networkChangedHandler),e.removeListener("accountsChanged",this.accountsChangedHandler))})),e.isMetaMask&&(e.autoRefreshOnNetworkChange=!1)}async getProvider(){const{ethereum:e}=window;return e}async getAccount(e){const t=super.getAccount(e);if(null===t){const e=Error("Ethereum account locked.");throw e.code=h.errorCodes.UNLOCK_REQUIRED,e}return t}onDeactivation(){this.runOnDeactivation.forEach(e=>e()),this.runOnDeactivation=[]}networkChangedHandler(e){const t=Number(e);try{super._validateNetworkId(t),super._web3UpdateHandler({updateNetworkId:!0,networkId:t})}catch(e){super._web3ErrorHandler(e)}}accountsChangedHandler(e){if(e[0])super._web3UpdateHandler({updateAccount:!0,account:e[0]});else{const e=Error("Ethereum account locked.");e.code=h.errorCodes.UNLOCK_REQUIRED,super._web3ErrorHandler(e)}}}var w=r(0);class p extends d{constructor(e){const{providerURL:t,...r}=e;super(r),this.providerURL=t}async onActivation(){if(!this.engine){const e=new w.Web3ProviderEngine;this.engine=e,this.engine.addProvider(new w.RPCSubprovider(this.providerURL))}this.engine.start()}async getProvider(){return this.engine}async getAccount(){return null}onDeactivation(){this.engine&&this.engine.stop()}}class l extends d{constructor(e){const{providerURL:t,privateKey:r,...n}=e;super(n),this.providerURL=t,this.privateKey=r}async onActivation(){if(!this.engine){const e=new w.Web3ProviderEngine;this.engine=e,this.engine.addProvider(new w.PrivateKeyWalletSubprovider(this.privateKey)),this.engine.addProvider(new w.RPCSubprovider(this.providerURL))}this.engine.start()}async getProvider(){return this.engine}async getAccount(){return this.engine._providers[0]._address}onDeactivation(){this.engine&&this.engine.stop()}}var b=class extends s.a{constructor(){super(),this._account=void 0,this._connectorName=void 0,this._error=null,this._networkId=void 0,this._provider=void 0,this._active=!1}get account(){return this._account}get connectorName(){return this._connectorName}get error(){return this._error}get networkId(){return this._networkId}get provider(){return this._provider}get active(){return this._active}set account(e){e!==this._account&&(this._account=e,this.emit("accountChanged",e))}set connectorName(e){e!==this._connectorName&&(this._connectorName=e,this.emit("connectorChanged",e))}set error(e){e!==this._error&&(this._error=e,e&&this.emit("error",e))}set networkId(e){e!==this._networkId&&(this._networkId=e,this.emit("networkChanged",e))}set provider(e){e!==this._provider&&(this._provider=e,this.emit("providerChanged",e))}set active(e){e!==this._active&&(this._active=e,this.emit("active",e))}};const v=["UNEXPECTED_ERROR","ALL_CONNECTORS_INVALID"].reduce((e,t)=>(e[t]=t,e),{}),_=Error("web3-vanila encountered an unexpected internal error. See the console for details.");_.code=v.UNEXPECTED_ERROR;const E={account:void 0,connectorName:void 0,error:null,networkId:void 0,provider:void 0};function g(e){return null===e?e:o.ethers.utils.getAddress(e)}var C=class{constructor(e){[this.refId,this.incrementRefId]=function(){const e=function(e=null){return{current:e}}(0);return[e,function(){e.current+=1}]}(),this.connectors=e,this.web3State=new b}get web3Initialized(){return!(void 0===this.web3State.account||!this.web3State.connectorName||this.web3State.error||!this.web3State.provider||!this.web3State.networkId)}get activeConnector(){return this.web3State.connectorName?this.connectors[this.web3State.connectorName]:void 0}updateWeb3State(e){this.web3State.account=e.account,this.web3State.connectorName=e.connectorName,this.web3State.error=e.error,this.web3State.networkId=e.networkId,this.web3State.provider=e.provider,this.web3State.active=this.web3Initialized}actionWeb3State(e){const t={account:this.web3State.account,connectorName:this.web3State.connectorName,error:this.web3State.error,networkId:this.web3State.networkId,provider:this.web3State.provider};switch(e.type){case"UPDATE_CONNECTOR_VALUES":{const{connectorName:t,provider:r,networkId:n,account:o}=e.payload;return this.updateWeb3State({connectorName:t,provider:r,networkId:n,account:g(o),error:null})}case"UPDATE_NETWORK_ID":{const{provider:r,networkId:n}=e.payload;return this.updateWeb3State({...t,provider:r||t.provider,networkId:n,error:null})}case"UPDATE_ACCOUNT":{const{provider:r,account:n}=e.payload;return this.updateWeb3State({...t,provider:r||t.provider,account:g(n),error:null})}case"UPDATE_NETWORK_ID_AND_ACCOUNT":{const{provider:r,networkId:n,account:o}=e.payload;return this.updateWeb3State({...t,provider:r||t.provider,account:g(o),error:null,networkId:n})}case"SET_ERROR":return this.updateWeb3State({...E,error:e.payload});case"SET_ERROR_PRESERVE_CONNECTOR_NAME":return this.updateWeb3State({...E,connectorName:t.connectorName,error:e.payload});case"SET_ERROR_WITH_CONNECTOR_NAME":{const{connectorName:t,error:r}=e.payload;return this.updateWeb3State({...E,connectorName:t,error:r})}case"RESET":return this.updateWeb3State(E);default:return console.warn("Default case encountered in actionWeb3State. Please file an issue on Github."),this.updateWeb3State({...t,provider:void 0,networkId:void 0,account:void 0,error:_})}}setError(e,{preserveConnector:t=!0,connectorName:r}={}){r&&this.actionWeb3State({type:"SET_ERROR_WITH_CONNECTOR_NAME",payload:{error:e,connectorName:r}}),t?this.actionWeb3State({type:"SET_ERROR_PRESERVE_CONNECTOR_NAME",payload:e}):this.actionWeb3State({type:"SET_ERROR",payload:e})}offConnector(){const e=this.activeConnector;e&&(this._web3UpdateHandler&&e.removeListener("_web3Update",this._web3UpdateHandler),this._web3ErrorHandler&&e.removeListener("_web3Error",this._web3ErrorHandler),this._web3ResetHandler&&e.removeListener("_web3Reset",this._web3ResetHandler),e.onDeactivation(this.web3State.error))}onConnector(){const e=this.activeConnector;e&&(this._web3UpdateHandler=this.web3UpdateHandler.bind(this),this._web3ErrorHandler=this.web3ErrorHandler.bind(this),this._web3ResetHandler=this.web3ResetHandler.bind(this),e.on("_web3Update",this._web3UpdateHandler),e.on("_web3Error",this._web3ErrorHandler),e.on("_web3Reset",this._web3ResetHandler))}async setConnector(e,{suppressAndThrowErrors:t=!1,networkId:r}={}){const n=this.refId.current;this.incrementRefId();const o=Object.keys(this.connectors),i=this.connectors[e];if(o.includes(e))if(e!==this.web3State.connectorName)try{await i.onActivation();const o=await i.getProvider(r),s=i.getNetworkId(o),a=i.getAccount(o);await Promise.all([s,a]).then(([t,r])=>{this.refId.current===n+1?(this.actionWeb3State({payload:{connectorName:e,provider:o,networkId:t,account:r},type:"UPDATE_CONNECTOR_VALUES"}),this.onConnector()):console.warn(`Silently suppressing status update from stale connector '${e}'.`)})}catch(r){if(this.refId.current!==n+1)return void console.warn(`Silently handling error from '${e}': ${r.toString()}`);if(t)throw r;this.setError(r,{connectorName:e})}else console.warn(`'${e}' is already set. Calling 'setConnector' for a connector while it is active is a no-op.'`);else console.warn(`'${e}' is not a valid name, please pass one of: ${o.join(", ")}.`)}async setFirstValidConnector(e,{suppressAndThrowErrors:t=!1,networkIds:r=[]}={}){for(const n of e)try{await this.setConnector(n,{suppressAndThrowErrors:!0,networkId:r[e.indexOf(n)]});break}catch(r){if(n===e[e.length-1]){const e=Error("Unable to set any valid connector.");if(e.code=v.ALL_CONNECTORS_INVALID,t)throw e;this.setError(e)}}}unsetConnector(){this.offConnector(),this.actionWeb3State({type:"RESET"})}async web3UpdateHandler({updateNetworkId:e=!1,updateAccount:t=!1,overrideNetworkIdCheck:r=!1,overrideAccountCheck:n=!1,networkId:o,account:i}={}){if(!this.activeConnector)return console.warn("No active connector in web3UpdateHandler call. Please file an issue on Github."),void this.setError(_);if(!e&&!t||e&&r&&!o||t&&n&&!i)return console.warn("Malformed parameters passed to web3UpdateHandler."),void this.setError(_);if((!e||e&&r)&&(!t||t&&n))e&&!t?this.actionWeb3State({payload:{networkId:o},type:"UPDATE_NETWORK_ID"}):!e&&t?this.actionWeb3State({payload:{account:i},type:"UPDATE_ACCOUNT"}):this.actionWeb3State({payload:{networkId:o,account:i},type:"UPDATE_NETWORK_ID_AND_ACCOUNT"});else try{const s=!this.web3State.provider||e&&!r,a=await(s?this.activeConnector.getProvider(o):this.web3State.provider),c=void 0===this.web3State.networkId||e&&!r,d=void 0===this.web3State.networkId||c?this.activeConnector.getNetworkId(a):this.web3State.networkId,u=void 0===this.web3State.account||t&&!n,h=void 0===this.web3State.account||u?this.activeConnector.getAccount(a):this.web3State.account;await Promise.all([d,h]).then(([r,n])=>{if(e&&o&&o!==r)throw console.warn(`Mismatched networkIds in web3UpdateHandler: ${o} and ${r}.`),_;if(t&&i&&g(i)!==g(n))throw console.warn(`Mismatched accounts in web3UpdateHandler: ${g(i)} and ${g(n)}.`),_;c&&!u?this.actionWeb3State({payload:{provider:s?a:void 0,networkId:r},type:"UPDATE_NETWORK_ID"}):!c&&u?this.actionWeb3State({payload:{provider:s?a:void 0,account:n},type:"UPDATE_ACCOUNT"}):this.actionWeb3State({payload:{provider:s?a:void 0,networkId:r,account:n},type:"UPDATE_NETWORK_ID_AND_ACCOUNT"})})}catch(e){this.setError(e)}}web3ErrorHandler(e,t=!0){this.setError(e,{preserveConnector:t})}web3ResetHandler(){this.unsetConnector()}};var f=class{constructor({connectors:e,libraryName:t=null,web3Api:r=null}){this._libraryName=t,this.web3Api=r,this._web3Manger=new C(e),this.setConnector=this._web3Manger.setConnector.bind(this._web3Manger),this.setFirstValidConnector=this._web3Manger.setFirstValidConnector.bind(this._web3Manger),this.unsetConnector=this._web3Manger.unsetConnector.bind(this._web3Manger),this.setError=this._web3Manger.setError.bind(this._web3Manger)}get library(){return this.provider&&(()=>{switch(this._libraryName){case"ethers.js":return this.web3Api=o.ethers,new o.ethers.providers.Web3Provider(this.provider);case"web3.js":if(!this.web3Api){const e=Error("web3Api is not exists.");throw e.code="WEB3_API_NOT_EXISTS",e}return new this.web3Api(this.provider);case null:return this.provider}})()}get event(){return this._web3Manger.web3State}get connector(){return this._web3Manger.activeConnector}get active(){return this._web3Manger.web3State.active}get connectorName(){return this._web3Manger.web3State.connectorName}get provider(){return this._web3Manger.web3State.provider}get networkId(){return this._web3Manger.web3State.networkId}get account(){return this._web3Manger.web3State.account}get error(){return this._web3Manger.web3State.error}};r.d(t,"subproviders",function(){return w}),r.d(t,"Connectors",function(){return n});t.default=f}])});